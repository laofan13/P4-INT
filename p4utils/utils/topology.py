"""This module includes all the features needed to query the ``topology.json`` file
generated by *P4-Utils* upon execution. Indeed, it allows the usage of topology
information in the controller code, so that the switches can be configured properly.

The topology file can be imported in a Python script by using the utility 
:py:func:`~p4utils.utils.helper.load_topo()`, as shown in the following example::

    from p4utils.utils.helper import load_topo

    topo = load_topo('topology.json')
"""

import networkx as nx
from ipaddress import ip_interface

class InvalidHostIP(Exception):
    """Exception raised when a wrong host IP is provided."""
    def __init__(self, ip):
        self.message = "".format(ip)
        super(InvalidHostIP, self).__init__('InvalidHostIP: {}'.format(self.message))

    def __str__(self):
        return self.message

class NodeDoesNotExist(Exception):
    """Exception raised when a node is not found."""

    def __init__(self, node):
        self.message = 'node <{}> does not exist.'.format(node)
        super().__init__('NodeDoesNotExist: {}'.format(self.message))

    def __str__(self):
        return self.message

class IntfDoesNotExist(Exception):
    """Exception raised when an interface is not found.

    Args:
        arg1 (str): first argument
        arg2 (str): second argument
        mode (int): working mode

    Possible **mode** values are the following:

    - ``0``, then **arg1** is the name of the missing interface and 
      **arg2** is the name of the node to which the interface belongs.
    - ``1``, then **arg1** is the name of the node to which the interface
      belongs and **arg2** is the name of the node that the interface
      is facing.
    """

    def __init__(self, arg1, arg2, mode=0):
        if mode == 0:
            self.message = 'interface <{}> does not exist on node <{}>.'.format(arg1, arg2)
        elif mode == 1:
            self.message = 'no interface facing node <{1}> exists on node <{0}>.'.format(arg1, arg2)
        super().__init__('IntfDoesNotExist: {}'.format(self.message))

    def __str__(self):
        return self.message

class NetworkGraph(nx.Graph):
    """Querying API that allows retrieving information about the
    network topology. It also provides useful methods to perform
    graph computation (e.g. Dijkstra's algorithm to get shortest paths).

    Note:
        To use this class in your Python code, you need to import the network
        topology JSON file (automatically generated by any execution of *P4-Utils*).
        This can be easily done with the function :py:func:`~p4utils.utils.helper.load_topo()`.

    Attributes:
        edge_to_intf (:py:class:`dict`): stores interface information indexed by ``[node1][node2]``,
                                         where the interface belongs to ``node1`` and 
                                         is facing ``node2``.
        node_to_intf (:py:class:`dict`): stores interface information indexed by ``[node][intfName]``,
                                         where the interface belongs to ``node`` and 
                                         is named according to ``intfName``.
        ip_to_host (:py:class:`dict`)  : stores hosts information indexed by ``[ip]``.
    """

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.edge_to_intf = {}
        self.node_to_intf = {}
        self.ip_to_host = {}
        self._populate_dicts()

    def _populate_dicts(self):
        """Populates the attributes ``intf_to_edge``, ``edge_to_intfs`` and 
        ``node_to_edges`` with the appropriate information to speed up searches. 
        This is done by using properties and methods of the parent class.
        """
        for node in self.nodes:
            self.edge_to_intf[node] = {}
            self.node_to_intf[node] = {}

        for node in self.nodes:
            if self.isHost(node):
                ip = self.nodes[node].get('ip')
                if ip is not None:
                    self.ip_to_host[ip.split("/")[0]] = {'name': node}
                    self.ip_to_host[ip.split("/")[0]].update(self.nodes[node])

            for neighbor in self.neighbors(node):
                self.edge_to_intf[node][neighbor] = self._edge_to_intf(node, neighbor)
                self.edge_to_intf[neighbor][node] = self._edge_to_intf(neighbor, node)
                self.node_to_intf[node][self.edge_to_intf[node][neighbor]['intfName']] = self.edge_to_intf[node][neighbor]
                self.node_to_intf[neighbor][self.edge_to_intf[neighbor][node]['intfName']] = self.edge_to_intf[neighbor][node]

    def _edge_to_intf(self, node1, node2):
        """Gets interface information of *node1* facing *node2*.
        
        Returns:
            dict: interfaces information indexed by ``[node1][node2]``.
        """
        link = self.edges[(node1, node2)]
        intf = {}
        # Get information about node1
        if node1 == link['node1'] and node2 == link['node2']:
            for key, value in link.items():
                if '2' not in key:
                    intf[key.replace('1','')] = value
                else:
                    intf[key.replace('2','_neigh')] = value

        # Get information about node2
        else:
            for key, value in link.items():
                if '1' not in key:
                    intf[key.replace('2','')] = value
                else:
                    intf[key.replace('1','_neigh')] = value
        return intf

    def get_intfs(self, fields=[]):
        """Retrieves all the interfaces and their configuration parameters using 
        the *nodes* as indexes.

        Args:
            fields (list): optional list of :py:class:`str` that specifies which
                           parameters need to be retrieved (and in which order)

        Returns:
            dict: the attribute ``edge_to_intf`` if ``fields`` is empty, or a dictionary of
            dictionaries of tuples, where the first two dictionaries are indexed by node and 
            the tuples contain the values of the specified interface configuration parameters
            in the exact order they are placed in ``fields``.

        Note:
            If only one element is present in ``fields``, then no tuple is created and
            the value is directly put in the inner dictionary.

        Example:
            Let us consider the following example to clarify::

                >>> topo = NetworkGraph()
                >>> ...
                >>> print(topo.get_intfs())
                {'h1': {'s2': {'port': 0, 'port_neigh': 1, ...}, ...}, ...}
                >>> print(topo.get_intfs(fields=['port', 'port_neigh']))
                {'h1': {'s2': (0, 1), ...}, ...}
                >>> print(topo.get_intfs(fields=['port']))
                {'h1': {'s2': 0, ...}, ...}
        """
        if len(fields) > 0:
            reduced_intfs = {}
            for node_a in self.edge_to_intf:
                reduced_intfs[node_a] = {}
                for node_b in self.edge_to_intf[node_a]:
                    reduced_intfs[node_a][node_b] = []
                    for field in fields:
                        reduced_intfs[node_a][node_b].append(self.edge_to_intf[node_a][node_b].get(field))
                    reduced_intfs[node_a][node_b] = tuple(reduced_intfs[node_a][node_b])
                    if len(fields) == 1:
                        reduced_intfs[node_a][node_b] = reduced_intfs[node_a][node_b][0]
            return reduced_intfs
        else:
            return self.edge_to_intf

    def get_node_intfs(self, fields=[]):
        """Retrieves all the interfaces and their configuration parameters using *node*
        and *interface name* as indexes.

        Args:
            fields (list): optional list of :py:class:`str` that specifies which
                           parameters need to be retrieved (and in which order)

        Returns:
            dict: the attribute ``node_to_intf`` if ``fields`` is empty, or a dictionary of
            dictionaries of tuples, where the first  dictionary is indexed by node, the second
            one by interface name and the tuples contain the values of the specified interface 
            configuration parameters in the exact order they are placed in ``fields``.

        Note:
            If only one element is present in ``fields``, then no tuple is created and
            the value is directly put in the inner dictionary.

        Example:
            Let us consider the following example to clarify::

                >>> topo = NetworkGraph()
                >>> ...
                >>> print(topo.get_node_intfs())
                {'h1': {'h1-eth0':{'port': 0, 'port_neigh': 1, ...}, ...}, ...}
                >>> print(topo.get_node_intfs(fields=['port', 'port_neigh']))
                {'h1': {'h1-eth0': (0, 1), ...}, ...}
                >>> print(topo.get_node_intfs(fields=['port']))
                {'h1': {'h1-eth0': 0, ...}, ...}
        """
        if len(fields) > 0:
            reduced_intfs = {}
            for node in self.node_to_intf:
                reduced_intfs[node] = {}
                for intf in self.node_to_intf[node]:
                    reduced_intfs[node][intf] = []
                    for field in fields:
                        reduced_intfs[node][intf].append(self.node_to_intf[node][intf].get(field))
                    reduced_intfs[node][intf] = tuple(reduced_intfs[node][intf])
                    if len(fields) == 1:
                        reduced_intfs[node][intf] = reduced_intfs[node][intf][0]
            return reduced_intfs
        else:
            return self.node_to_intf

    def get_nodes(self, fields=[]):
        """Retrieves all the nodes and their configuration parameters.

        Args:
            fields (list): optional list of :py:class:`str` that specifies which
                           parameters need to be retrieved (and in which order)

        Returns:
            dict: all the nodes configuration parameters if ``fields`` is empty, or
            a dictionary of tuples, where the first one is indexed by node name and
            the second ones collect the values of the selected parameters in the exact
            order they are placed in ``fields``.

        Note:
            If only one element is present in ``fields``, then no tuple is created and
            the value is directly put in the dictionary.
        
        Example:
            Let us consider the following example to clarify::

                >>> topo = NetworkGraph()
                >>> ...
                >>> print(topo.get_nodes())
                {'h1':{'isHost': True, 'isSwitch': False, ...}, ...}
                >>> print(topo.get_nodes(fields=['isHost', 'isSwitch']))
                {'h1': (True, False), ...}
                >>> print(topo.get_nodes(fields=['isHost']))
                {'h1': True, ...}
        """
        nodes = dict(self.nodes)
        if len(fields) > 0:
            reduced_nodes = {}
            for node in nodes:
                reduced_nodes[node] = []
                for field in fields:
                    reduced_nodes[node].append(nodes[node].get(field))
                reduced_nodes[node] = tuple(reduced_nodes[node])
                if len(fields) == 1:
                    reduced_nodes[node] = reduced_nodes[node][0]
            return reduced_nodes
        else:
            return nodes

    def get_switches(self, fields=[]):
        """Retrieves all the switches and their configuration parameters.

        Args:
            fields (list): optional list of :py:class:`str` that specifies which
                           parameters need to be retrieved (and in which order)

        Returns:
            dict: all the switches configuration parameters if ``fields`` is empty, or
            a dictionary of tuples, where the first one is indexed by switch name and
            the second ones collect the values of the selected parameters in the exact
            order they are placed in ``fields``.

        Note:
            If only one element is present in ``fields``, then no tuple is created and
            the value is directly put in the dictionary.
        
        Example:
            Let us consider the following example to clarify::

                >>> topo = NetworkGraph()
                >>> ...
                >>> print(topo.get_switches())
                {'s1':{'isHost': False, 'isSwitch': True, ...}, ...}
                >>> print(topo.get_switches(fields=['isHost', 'isSwitch']))
                {'s1': (False, True), ...}
                >>> print(topo.get_switches(fields=['isHost']))
                {'s1': False, ...}
        """
        switches_subgraph = nx.subgraph_view(self, filter_node=self.isSwitch)
        switches = dict(switches_subgraph.nodes)
        if len(fields) > 0:
            reduced_switches = {}
            for switch in switches:
                reduced_switches[switch] = []
                for field in fields:
                    reduced_switches[switch].append(switches[switch].get(field))
                reduced_switches[switch] = tuple(reduced_switches[switch])
                if len(fields) == 1:
                    reduced_switches[switch] = reduced_switches[switch][0]
            return reduced_switches
        else:
            return switches

    def get_p4switches(self, fields=[]):
        """Retrieves all the P4 switches and their configuration parameters.

        Args:
            fields (list): optional list of :py:class:`str` that specifies which
                           parameters need to be retrieved (and in which order)

        Returns:
            dict: all the switches configuration parameters if ``fields`` is empty, or
            a dictionary of tuples, where the first one is indexed by switch name and
            the second ones collect the values of the selected parameters in the exact
            order they are placed in ``fields``.

        Note:
            If only one element is present in ``fields``, then no tuple is created and
            the value is directly put in the dictionary.
        
        Example:
            Let us consider the following example to clarify::

                >>> topo = NetworkGraph()
                >>> ...
                >>> print(topo.get_p4switches())
                {'s1':{'isHost': False, 'isSwitch': True, ...}, ...}
                >>> print(topo.get_p4switches(fields=['isHost', 'isSwitch']))
                {'s1': (False, True), ...}
                >>> print(topo.get_p4switches(fields=['isHost']))
                {'s1': False, ...}
        """
        p4switches_subgraph = nx.subgraph_view(self, filter_node=self.isP4Switch)
        p4switches = dict(p4switches_subgraph.nodes)
        if len(fields) > 0:
            reduced_p4switches = {}
            for p4switch in p4switches:
                reduced_p4switches[p4switch] = []
                for field in fields:
                    reduced_p4switches[p4switch].append(p4switches[p4switch].get(field))
                reduced_p4switches[p4switch] = tuple(reduced_p4switches[p4switch])
                if len(fields) == 1:
                    reduced_p4switches[p4switch] = reduced_p4switches[p4switch][0]
            return reduced_p4switches
        else:
            return p4switches

    def get_p4rtswitches(self, fields=[]):
        """Retrieves all the P4Runtime switches and their configuration parameters.

        Args:
            fields (list): optional list of :py:class:`str` that specifies which
                           parameters need to be retrieved (and in which order)

        Returns:
            dict: all the switches configuration parameters if ``fields`` is empty, or
            a dictionary of tuples, where the first one is indexed by switch name and
            the second ones collect the values of the selected parameters in the exact
            order they are placed in ``fields``.

        Note:
            If only one element is present in ``fields``, then no tuple is created and
            the value is directly put in the dictionary.
        
        Example:
            Let us consider the following example to clarify::

                >>> topo = NetworkGraph()
                >>> ...
                >>> print(topo.get_p4rtswitches())
                {'s1':{'isHost': False, 'isSwitch': True, ...}, ...}
                >>> print(topo.get_p4rtswitches(fields=['isHost', 'isSwitch']))
                {'s1': (False, True), ...}
                >>> print(topo.get_p4rtswitches(fields=['isHost']))
                {'s1': False, ...}
        """
        p4rtswitches_subgraph = nx.subgraph_view(self, filter_node=self.isP4RuntimeSwitch)
        p4rtswitches = dict(p4rtswitches_subgraph.nodes)
        if len(fields) > 0:
            reduced_p4rtswitches = {}
            for p4rtswitch in p4rtswitches:
                reduced_p4rtswitches[p4rtswitch] = []
                for field in fields:
                    reduced_p4rtswitches[p4rtswitch].append(p4rtswitches[p4rtswitch].get(field))
                reduced_p4rtswitches[p4rtswitch] = tuple(reduced_p4rtswitches[p4rtswitch])
                if len(fields) == 1:
                    reduced_p4rtswitches[p4rtswitch] = reduced_p4rtswitches[p4rtswitch][0]
            return reduced_p4rtswitches
        else:
            return p4rtswitches

    def get_hosts(self, fields=[]):
        """Retrieves all the hosts and their configuration parameters.

        Args:
            fields (list): optional list of :py:class:`str` that specifies which
                           parameters need to be retrieved (and in which order)

        Returns:
            dict: all the hosts configuration parameters if ``fields`` is empty, or
            a dictionary of tuples, where the first one is indexed by host name and
            the second ones collect the values of the selected parameters in the exact
            order they are placed in ``fields``.

        Note:
            If only one element is present in ``fields``, then no tuple is created and
            the value is directly put in the dictionary.
        
        Example:
            Let us consider the following example to clarify::

                >>> topo = NetworkGraph()
                >>> ...
                >>> print(topo.get_hosts())
                {'h1':{'isHost': True, 'isSwitch': False, ...}, ...}
                >>> print(topo.get_hosts(fields=['isHost', 'isSwitch']))
                {'h1': (True, False), ...}
                >>> print(topo.get_hosts(fields=['isHost']))
                {'h1': True, ...}
        """
        hosts_subgraph = nx.subgraph_view(self, filter_node=self.isHost)
        hosts = dict(hosts_subgraph.nodes)
        if len(fields) > 0:
            reduced_hosts = {}
            for host in hosts:
                reduced_hosts[host] = []
                for field in fields:
                    reduced_hosts[host].append(hosts[host].get(field))
                reduced_hosts[host] = tuple(reduced_hosts[host])
                if len(fields) == 1:
                    reduced_hosts[host] = reduced_hosts[host][0]
            return reduced_hosts
        else:
            return hosts

    def get_routers(self, fields=[]):
        """Retrieves all the routers and their configuration parameters.

        Args:
            fields (list): optional list of :py:class:`str` that specifies which
                           parameters need to be retrieved (and in which order)

        Returns:
            dict: all the routers configuration parameters if ``fields`` is empty, or
            a dictionary of tuples, where the first one is indexed by router name and
            the second ones collect the values of the selected parameters in the exact
            order they are placed in ``fields``.

        Note:
            If only one element is present in ``fields``, then no tuple is created and
            the value is directly put in the dictionary.
        
        Example:
            Let us consider the following example to clarify::

                >>> topo = NetworkGraph()
                >>> ...
                >>> print(topo.get_routers())
                {'r1':{'isHost': False, 'isRouter': True, ...}, ...}
                >>> print(topo.get_routers(fields=['isHost', 'isRouter']))
                {'r1': (False, True), ...}
                >>> print(topo.get_routers(fields=['isHost']))
                {'r1': False, ...}
        """
        routers_subgraph = nx.subgraph_view(self, filter_node=self.isRouter)
        routers = dict(routers_subgraph.nodes)
        if len(fields) > 0:
            reduced_routers = {}
            for router in routers:
                reduced_routers[router] = []
                for field in fields:
                    reduced_routers[router].append(routers[router].get(field))
                reduced_routers[router] = tuple(reduced_routers[router])
                if len(fields) == 1:
                    reduced_routers[router] = reduced_routers[router][0]
            return reduced_routers
        else:
            return routers

    def get_neighbors(self, name):
        """Retrieves the neighbors of a node.

        Args:
            name (str): node name

        Returns:
            list: list of neighbors names.
        """
        #return list(self.get_intfs()[name].keys())
        return list(self.neighbors(name))
        

    def isNode(self, name):
        """Checks if the node exists.

        Args:
            name (str): node name

        Returns:
            bool: **True** if the node exists, **False** otherwise.
        """
        return name in self.get_nodes()

    def checkNode(self, name):
        """Sanity check on node existence.

        Args:
            name (str): node name

        Raises:
            NodeDoesNotExist: if the given node does not exist.
        """
        if not self.isNode(name):
            raise NodeDoesNotExist(name)

    def isIntf(self, node1, node2):
        """Checks if the interface between *node1* and *node2* exists.

        Args:
            node1 (str): name of the first node
            node2 (str): name of the second node

        Returns:
            bool: **True** if the interface exists, **False** otherwise.
        """
        if node1 not in self.edge_to_intf:
            return False
        if node2 not in self.edge_to_intf[node1]:
            return False
        return True

    def checkIntf(self, node1, node2):
        """Sanity check on interface existence.

        Args:
            node1 (str): name of the first node
            node2 (str): name of the second node

        Raises:
            IntfDoesNotExist: if the given interface does not exist.
        """
        if not self.isIntf(node1, node2):
            raise IntfDoesNotExist(node1, node2, mode=1)

    def isHost(self, name):
        """Checks if a node is a host.

        Args:
            name (str): node name

        Returns:
            bool: **True** if the node is a host, **False** otherwise.
        """
        self.checkNode(name)
        return self.get_nodes()[name].get('isHost', False)

    def isSwitch(self, name):
        """Checks if a node is a switch.

        Args:
            name (str): node name

        Returns:
            bool: **True** if the node is a switch, **False** otherwise.
        """
        self.checkNode(name)
        return self.get_nodes()[name].get('isSwitch', False)

    def isP4Switch(self, name):
        """Checks if a node is a P4 switch.

        Args:
            name (str): node name

        Returns:
            bool: **True** if the node is a P4 switch, **False** otherwise.
        """
        self.checkNode(name)
        return self.get_nodes()[name].get('isP4Switch', False)

    def isP4RuntimeSwitch(self, name):
        """Checks if a node is a P4Runtime switch.

        Args:
            name (str): node name

        Returns:
            bool: **True** if the node is a P4Runtime switch, **False** otherwise.
        """
        self.checkNode(name)
        return self.get_nodes()[name].get('isP4RuntimeSwitch', False)

    def isRouter(self, name):
        """Checks if a node is a router.

        Args:
            name (str): node name

        Returns:
            bool: **True** if the node is a router switch, **False** otherwise.
        """
        self.checkNode(name)
        return self.get_nodes()[name].get('isRouter', False)

    def isType(self, name, node_type):
        """Checks custom node type. 
        
        Args:
            name (str)     : node name
            node_type (str): type to check      

        Possible **node_type** values are the following:

        - ``host``
        - ``switch``
        - ``p4switch``
        - ``p4rtswitch``
        - ``router``

        Returns:
            bool: **True** if the node type matches with ``node_type``,
            **False** otherwise.
        """
        if node_type == 'host':
            return self.isHost(name)
        elif node_type == 'switch':
            return self.isSwitch(name)
        elif node_type == 'p4switch':
            return self.isP4Switch(name)
        elif node_type == 'p4rtswitch':
            return self.isP4RuntimeSwitch(name)
        elif node_type == 'router':
            return self.isRouter(name)
        else:
            print('Unknown node type {}.'.format(node_type))

    def _node_interface(self, node, intf):
        """Retrieves the configuration parameters of a node's interface,
        raising proper exceptions on errors.
        
        Args:
            node (str): node name
            intf (str): interface name

        Returns:
            dict: configuration parameters of the specified interface.

        Raises:
            NodeDoesNotExist: if ``node`` does not exist in the network.
            IntfDoesNotExist: if ``intf`` does not exist on the specified node.
        """
        try:
            intfs = self.node_to_intf[node]
        except KeyError:
            raise NodeDoesNotExist(node)
        try:
            return intfs[intf]
        except KeyError:
            raise IntfDoesNotExist(intf, node)

    def node_to_node_interface_ip(self, node1, node2):
        """Gets the IP address and the subnet mask of the interface of 
        *node1* facing *node2*.

        Args:
            node1 (str): name of the first node
            node2 (str): name of the second node
        
        Returns:
            str: IP / subnet mask of the interface.
        """
        self.checkIntf(node1, node2)
        return self.get_intfs()[node1][node2].get('ip')

    def node_to_node_interface_bw(self, node1, node2):
        """Gets the bandwidth of the interface of *node1* facing *node2*.

        Args:
            node1 (str): name of the first node
            node2 (str): name of the second node

        Returns:
            int: bandwidth capacity of the interface in Mbps.

        Note:
            If the bandwidth is unlimited, this method returns ``-1``.
        """
        self.checkIntf(node1, node2)
        if self.get_intfs()[node1][node2].get('bw') is None:
            return -1
        else:
            return self.get_intfs()[node1][node2]['bw']
    
    def node_interface_ip(self, node, intf):
        """Gets the IP address a given node's interface.
        
        Args:
            node (str): node name
            intf (str): interface name

        Returns:
            str: IP address of the interface
        """
        ip = self._node_interface(node, intf).get('ip')
        if ip is not None:
            return ip.split("/")[0]
        else:
            return None

    def node_interface_bw(self, node, intf):
        """Gets the bandwidth of a give node's interface.
        
        Args:
            node (str): node name
            intf (str): interface name

        Returns:
            int: bandwidth capacity of the interface in Mbps.

        Note:
            If the bandwidth is unlimited, this method returns ``-1``.
        """
        if self._node_interface(node, intf).get('bw') is None:
            return -1
        else:
            return self._node_interface(node, intf)['bw']

    def subnet(self, node1, node2):
        """Gets the subnet of the link between *node1* and *node2*.

        Args:
            node1 (str): name of the first node
            node2 (str): name of the second node

        Returns:
            str: the subnet in CIDR notation.
        """
        ip = self.node_to_node_interface_ip(node1, node2)
        if ip is not None:
            return ip_interface(ip).network.with_prefixlen
        else:
            return None

    def get_interfaces(self, name):
        """Retrieves all the interfaces of a node.

        Args:
            name (str): node name

        Returns:
            list: list of interfaces names.
        """
        self.checkNode(name)
        return list(self.node_to_intf[name].keys())

    def get_cpu_port_intf(self, name, quiet=False):
        """Retrieves the P4 switch's CPU interface, used for CPU packets.

        Args:
            name (str): name of the P4 switch

        Returns:
            str: name of the P4 switch's CPU interface.

        Note:
            Returns **None** if no CPU port is found.
        """
        if self.isP4Switch(name) and self.get_nodes()[name].get('cpu_port', False):
            return self.get_nodes()[name]['cpu_intf']
        else:
            if not quiet:
                print('Switch {} has no cpu port.'.format(name))
            return None

    def get_cpu_port_index(self, name, quiet=False):
        """Retrieves the P4 switch's CPU port number, used for CPU packets.

        Args:
            name (str): name of the P4 switch

        Returns:
            int: port number of the P4 switch's CPU interface.

        Note:
            Returns **None** if no CPU port is found.
        """
        if self.isP4Switch(name) and self.get_nodes()[name].get('cpu_port', False):
            return self.get_nodes()[name]['cpu_port_num']
        else:
            if not quiet:
                print('Switch {} has no cpu port.'.format(name))
            return None

    def get_thrift_port(self, name):
        """Retrieves the P4 switch's *Thrift* port number.

        Args:
            name (str): name of the P4 switch

        Returns:
            int: *Thrift* port to connect to.
        """
        if self.isP4Switch(name):
            return self.get_nodes()[name]['thrift_port']
        else:
            raise TypeError('{} is not a P4 switch.'.format(name))

    def get_thrift_ip(self, name):
        """Retrieves the P4 switch's IP where it listens for
        incoming *Thrift* connections.

        Args:
            name (str): name of the P4 switch

        Returns:
            str: IP to connect to.
        """
        if self.isP4Switch(name):
            print('This method is not yet fully implemented, all switches listen on 0.0.0.0.')
            return '0.0.0.0'
            #return self.get_nodes()[name]['thrift_ip']
        else:
            raise TypeError('{} is not a P4 switch.'.format(name))

    def get_grpc_port(self, name):
        """Retrieves the P4Runtime switch's gRPC port number.

        Args:
            name (str): name of the P4Runtime switch

        Returns:
            int: gRPC port to connect to.
        """
        if self.isP4RuntimeSwitch(name):
            return self.get_nodes()[name]['grpc_port']
        else:
            raise TypeError('{} is not a P4 runtime switch.'.format(name))

    def get_grpc_ip(self, name):
        """Retrieves the P4Runtime switch's IP where it listens for 
        incoming gRPC connections.

        Args:
            name (str): name of the P4Runtime switch

        Returns:
            str: IP to connect to.
        """
        if self.isP4RuntimeSwitch(name):
            print('This method is not yet fully implemented, all switches listen on 0.0.0.0.')
            return '0.0.0.0'
            #return self.get_nodes()[name]['thrift_ip']
        else:
            raise TypeError('{} is not a P4 switch.'.format(name))

    def get_ctl_cpu_intf(self, name):
        """Gets the controller side CPU interface, used to listen for CPU packets.

        Args:
            name (str): name of the P4 switch
        
        Returns:
            str: name of the controller side CPU interface.
        """
        if self.isP4Switch(name) and self.get_nodes()[name]['cpu_port']:
            return self.get_nodes()[name]['cpu_ctl_intf']
        else:
            raise TypeError('Switch {} has no cpu port.'.format(name))

    def get_host_name(self, ip):
        """Gets the host name from an IP address.

        Args:
            ip: host IP without prefix length

        Returns:
            str: name of the host whose IP corresponds to the one provided.

        Raises:
            InvalidHostIP: if the IP provided does not match any host.
        """
        host = self.ip_to_host.get(ip)
        if host:
            return host['name']
        else:
            raise InvalidHostIP(ip)
        
    def get_host_first_interface(self, name):
        """Gets the first interface of a host. 

        Args:
            name (str): host name

        Returns:
            str: interface name.
        """
        if self.isHost(name):
            return list(self.node_to_intf[name].keys())[0]
        else:
            raise TypeError('{} is not a host.'.format(name))

    def get_host_gateway_name(self, name):
        """Gets host's gateway.
        
        Args:
            name (str): host name

        Returns:
            str: gateway node name.

        Warning:
            This method assumes that the gateway is connected to the
            host via its first interface.
        """
        if self.isHost(name):
            return self._node_interface(name, self.get_host_first_interface(name))['node_neigh']
        else:
            raise TypeError('{} is not a host.'.format(name))
        
    def get_host_ip(self, name):
        """Gets host's IP address.

        Args:
            name (str): host name

        Returns:
            str: host's IP address.

        Warning:
            This method assumes that hosts are single-homed (i.e.
            with only one interface).
        """
        if self.isHost(name):
            ip = self.get_nodes()[name].get('ip')
            if ip is not None:
                return ip.split("/")[0]
            else:
                return None
        else:
            raise TypeError('{} is not a host.'.format(name))

    def get_host_mac(self, name):
        """Gets host's MAC address.

        Args:
            name (str): host name

        Returns:
            str: host's MAC address.

        Warning:
            This method assumes that hosts are single-homed (i.e.
            with only one interface).
        """
        self.checkNode(name)
        intf = self.get_host_first_interface(name)
        return self._node_interface(name, intf)['addr']

    def get_p4switch_id(self, name):
        """Gets the ID of a P4 switch.

        Args:
            name (str): P4 switch name in the topology

        Returns:
            int: ID of P4 switch as a string
        """
        if self.isP4Switch(name):
            return self.get_nodes()[name]['device_id']
        else:
            raise TypeError('{} is not a P4 switch.'.format(name))

    def are_neighbors(self, node1, node2):
        """Checks if two nodes are direct neighbors.

        Args:
            node1 (str): first node
            node2 (str): second node

        Returns:
            bool: **True** if the node are neighbors,
            **False** otherwise.
        """
        self.checkNode(node1)
        self.checkNode(node2)
        return node1 in self.get_neighbors(node2)
        
    def get_hosts_connected_to(self, name):
        """Gets hosts directly connected to a node.

        Args:
            name (str): node name

        Returns: 
            list: list of hosts names.
        """
        self.checkNode(name)
        nodes = self.get_neighbors(name)
        return [host for host in nodes if self.isHost(host)]

    def get_switches_connected_to(self, name):
        """Gets switches directly connected to a node.

        Args:
            name (str): node name

        Returns:
            list: list of switch names.
        """
        self.checkNode(name)
        nodes = self.get_neighbors(name)
        return [switch for switch in nodes if self.isSwitch(switch)]

    def get_p4switches_connected_to(self, name):
        """Gets the P4 switches directly connected to a node.

        Args:
            name (str): node name

        Returns:
            list: list of P4 switch names.
        """
        self.checkNode(name)
        nodes = self.get_neighbors(name)
        return [switch for switch in nodes if self.isP4Switch(switch)]

    def get_routers_connected_to(self, name):
        """Gets the routers directly connected to a node.

        Args:
            name (str): node name

        Returns:
            list: list of routers.
        """
        self.checkNode(name)
        nodes = self.get_neighbors(name)
        return [router for router in nodes if self.isRouter(router)]

    def get_direct_host_networks_from_switch(self, name):
        """Gets all the subnetworks a switch can reach directly.

        Args:
            name (str): switch name

        Returns:
            a :py:class:`set` of subnetworks.
        """
        self.checkNode(name)
        networks = []
        hosts = self.get_hosts_connected_to(name)
        for host in hosts:
            networks += [self.subnet(host, name)]
        return set(networks)

    def get_interfaces_to_node(self, node):
        """Gets dictionary that associates every node's interface to its
        connected neighbor.

        Args:
            name (str): node name.

        Returns:
            dict: dictionary of node's neighbors indexed by the corresponding
            node's interfaces.
        """
        self.checkNode(node)
        intfs = {}
        for intf, params in self.node_to_intf[node].items():
            intfs[intf] = params['node_neigh']
        return intfs
    
    def interface_to_node(self, node, intf):
        """Gets name of the node's neighbor attached to the specified interface.

        Args:
            node (str): node name
            intf (str): interface name

        Returns:
            str: neighbor name.
        """
        return self._node_interface(node, intf)['node_neigh']

    def interface_to_port(self, node, intf):
        """Gets port number of the the specified interface of a node.

        Args:
            node (str): node name
            intf (str): interface name

        Returns:
            int: port number.
        """
        return self._node_interface(node, intf)['port']

    def port_to_node(self, node, port):
        """Gets the neighboring node  of *node* connected to *port*.

        Args:
            node (str): name of the first node
            port (int):  port number 

        Returns:
            str: neighbor node.
        """

        # TODO: this function probably has to be done differently.
        for neighbor in self.get_neighbors(node):
            if port == self.node_to_node_port_num(node, neighbor):
                return neighbor

        # TODO: also fix this..
        raise Exception("Node {} does not have port {}".format(node, port))
        
    def node_to_node_port_num(self, node1, node2):
        """Gets the number of the port of *node1* that is connected to *node2*.

        Args:
            node1 (str): name of the first node
            node2 (str): name of the second node

        Returns:
            int: port number.
        """
        self.checkIntf(node1, node2)
        return self.get_intfs()[node1][node2].get('port')

    def node_to_node_mac(self, node1, node2):
        """Gets the MAC address of the interface of *node1* connected to *node2*.

        Args:
            node1 (str): name of the first node
            node2 (str): name of the second node

        Returns:
            str: MAC address.
        """
        self.checkIntf(node1, node2)
        return self.get_intfs()[node1][node2].get('addr')

    def total_number_of_paths(self):
        """Computes the total number of shortest paths between all
        host pairs in the network.
        
        Returns:
            int: number of paths.
        """
        total_paths = 0
        for host in self.get_hosts():
            for host_pair in self.get_hosts():
                if host == host_pair:
                    continue
                # compute the number of paths
                npaths = sum(1 for _ in nx.all_shortest_paths(self, host, host_pair, 'weight'))
                total_paths += npaths
        return total_paths

    def get_shortest_paths_between_nodes(self, node1, node2):
        """Computes all the shortest paths between *node1* and *node2*.

        Args:
            node1: name of the starting node
            node2: name of the ending node

        Returns: 
            list: list of paths.

        Note:
            Each path is given as a :py:class:`tuple` of node names from the first to the
            last one.
        """
        self.checkNode(node1)
        self.checkNode(node2)
        paths = nx.all_shortest_paths(self, node1, node2, 'weight')
        paths = [tuple(x) for x in paths]
        return paths

    def get_all_paths_between_nodes(self, node1, node2):
        """Compute all the simple paths (i.e. with no repeated nodes)
        between *node1* and *node2*.
        
        Args:
            node1: name of the starting node
            node2: name of the ending node

        Returns: 
            list: list of paths.

        Note:
            Each path is given as a :py:class:`tuple` of node names from the first to the
            last one.
        """
        self.checkNode(node1)
        self.checkNode(node2)
        paths = nx.shortest_simple_paths(self, node1, node2, 'weight')
        paths = [tuple(x) for x in paths]
        return paths

    def keep_only_switches(self):
        """Returns a networkx subgraph including only switches."""
        return self.subgraph(list(self.get_switches().keys()))

    def keep_only_p4switches(self):
        """Returns a networkx subgraph including only P4 switches."""
        return self.subgraph(list(self.get_p4switches().keys()))

    def keep_only_p4switches_and_hosts(self):
        """Returns a networkx subgraph including only hosts and P4 switches."""
        return self.subgraph(list(self.get_p4switches().keys()) + list(self.get_hosts().keys()))

    # Drawing
    def set_node_shape(self, node, shape):
        """Sets node's shape. Used when plotting the network.
        
        Args:
            name (str): node name
            shape     : shape to assign
        """
        self.get_nodes()[node]['node_shape'] = shape

    def set_node_color(self, node, color):
        """Sets node's color. Used when plotting the network.
        
        Args:
            name (str): node name
            shape     : color to assign
        """
        self.get_nodes()[node]['node_color'] = color

    def set_node_type_shape(self, node_type, shape):
        """Sets the shape of the nodes filtered by type. Used when plotting the network.

        Args:
            node_type (str): node type to select
            shape          : shape to assign to nodes

        Possible values for **node_types** are the following:
        
        - ``host``
        - ``switch``
        - ``p4switch``
        - ``p4rtswitch``
        - ``router``
        """
        for node in self.get_nodes():
            if self.isType(self.get_nodes()[node], node_type):
                self.set_node_shape(node, shape)

    def set_node_type_color(self, node_type, color):
        """Sets the color of the nodes filtered by type. Used when plotting the network.

        Args:
            node_type (str): node type to select
            color          : color to assign to nodes

        Possible values for **node_types** are the following:
        
        - ``host``
        - ``switch``
        - ``p4switch``
        - ``p4rtswitch``
        - ``router``
        """
        for node in self.get_nodes():
            if self.isType(self.get_nodes()[node], node_type):
                self.set_node_color(node, color)
